# Thread 의 원자성 연산

---

>[참고 사이트1](https://javabom.tistory.com/94)
>
>[참고 사이트2](https://sslblog.tistory.com/201)
>
>[참고 사이트3](https://ccomccomhan.tistory.com/138)

## 동기화

1. 동기화에는 크게 2가지가 있다. 
   1. Synchronized
   2. volatie
2. Synchronized는 배타적수행, 안정적 통신을 모두수행하는 것이고, volatile은 안정적 통신만을 수행한다고 생각하면 편하다
3. "원자성 연산" 은 동기화와 관련이 있다. 

## 원자적 연산 

### 정의 

1. **중단이 불가능한 연산**
2. 자바 언어에서 long과 double을 제외한 **변수를 읽고 쓰는 동작은 원자적** 이다. (long과 double빼고 원자적 데이터임. )
   - 여러 쓰레드가 primitive 타입의 변수를 동기화 없이 수정하더라도, 각 스레드에서는 정상적으로 그 값을 온전하게 (연산중간에 끼어들지 않고 온전히) 읽어온다
   - 중간에 다른 쓰레드가 끼어들어서 연산의 결과가 올바르지 않게 변한다면 해당 연산은 원자적 연산이 아니다.

### 종류

1. 레퍼런스의 쓰기 또는 읽기
2. 원시타입의 쓰기 또는 읽기(`double`과 `long` 제외)

### double과 long를 읽는 것만 원자성 연산이 아닌 이유 

1. 자바 메모리 모델에 의하면 32비트 메모리에 값을 할당하는 연산은 중단이 불가능하다. (원자적이다)
   - 그렇지만 long과 double의 경우에는 64비트의 메모리 공간을 갖고있기 때문이다.
2. 즉 첫 비트 32비트 값을 할당한 직후에, 즉 둘째 32비트를 할당하기 직전에 다른 쓰레드가 끼어들어 두 32비트 값중 하나를 변경할 수 있기 때문에 long, double은 원자적 연산이 될 수 없다.
3. double과 long을 원자적 연산으로 하기 위해 volatile키워드를 사용한다. 

### volatile

```java
public class Test {

  public volatile long sharedValue;
}
```

1. 해당 필드에 접근할 때 *lock*을 걸어주는 역할을 한다. 
2. synchronized 와 차이점
   1. `synchronized` :  지정한 메서드나 지정한 블록에 thread-safe를 보장하는 
   2. `volatile` :  해당 필드의 접근에 대해서만 원자성을 보장
3. 사용이유
   1. 각 쓰레드에서 변경한 값을 값을 통신하기 위해 **동기화**가 필요하며, 이때 통신을 위한 동기화를 사용하기 위해서는 **volatile** 한정자를 사용하는 방법이 있다. 
   2. 즉, 여러 스레드가 공유하는 변수값을 읽어오기 위해서 **volatile** 키워드를 붙이면 그 변수를 읽어올때 각 쓰레드의 cached한 영역이 아닌 메인 메모리에서 직접 읽어오기 때문에 안정적인 통신을 보장할 수 있다. 

### 동기화  vs  원자적 연산

1. 동기화
   1. 멀티스레드 환경에서 여러 스레드가 공유하는 데이터를 안전하게 접근하고 조작하기 위해 사용하는 기술.
   2. 동기화는 **공유 데이터에 접근하는 스레드들이 서로 충돌하지 않도록 해주는 역할**을 한다.
2. 원자적 연산 
   1. **한번에 실행되거나 실행되지 않는 연산을 의미**.
   2. 원자적 연산은 연산이 실행되는 도중에 다른 스레드에 의해 방해받지 않는 것이 보장되어야 하며 **실행결과도 항상 일관성**이 있어야 한다.
3. 예시
   1. "i++" 연산은 하나의 단위 연산이 아니므로( 현재 i의 값을 읽어온다 > i에 1을 더한다) 여러 스레드가 "i++"를 동시에 실행하면 결과가 일관성 없이 나올 수 있다.
   2. 따라서, "i++"와 같은 연산이 원자적으로 실행되도록 보장하기 위해 AtomicInteger와 같은 **원자적 자료형을 사용**한다.

### 원자적 데이터에 동기화가 필요한이유  

1. 원자적 데이터를 읽고 쓸 때는 (할당 연산은 원자적이다) 동기화를 하지 않아도 괜찮다고 생각 할 수 있다. (중단이 불가능하기 때문에!)
   - 하지만 원자적 데이터라도 **동기화가 필요하다**
2. Java언어에서 스레드가 (원자적 데이터 값을 가지더라도) 필드를 읽을 때 '수정이 완전히 반영된' 값을 얻는다고 보장하지 않는다.
   - 즉 A 쓰레드에서 필드를 수정했더라도, B 쓰레드에서 수정된 필드를 반드시 볼 수 있는 것은 아니라는 것이다.
3. 따라서 한 쓰레드에서 수정이된 필드값을 다른 쓰레드에서 '잘 읽기' 위해서라도 **동기화의 안정적인 통신**이 필요하다
   - 이는 자바 메모리 모델 때문이다.

### 정리

1. 원자성 연산이란 일반변수 및 레퍼런스 변수의 연산이 진행될 때 다른 스레드의 간섭을 받지 않는 연산을 뜻한다. 
2. 이떄 원자성 연산이 되도록 구현을 해야하는데, double과 long은 64 비트이기 때문에 원자성 연산이 되지 않는다. 
3. 따라서 원자성 연산이 가능하도록 volatile 키워드를 붙여 사용하는것이 좋다. 
4. 차이점
   1. 동기화 : 여러 스레드 간의 공유 데이터 접근을 보호하기 위해 사용.
   2. 원자적 연산 : 하나의 연산이 원자적으로 실행되도록 보장하기 위해 사용.

