# Thread 경쟁 상태와 데이터 경쟁

---

>

### 데이터 경쟁 ( Data Race )

### 발생이유

- 컴파일러와 CPU가 성능 최적화와 하드웨어 활용을 위해 비순차적으로 명령을 처리하는 것 
  - 논리를 위반하지 않는 곳에서만 일어난다. 
- 스레드들이 공유 리소스를 사용하거나 스레드가 리소스를 수정하는 경우 발생한다. 

### 데이터 경쟁을 피하는 방법

1. 공유 변수에 Synchronized 를 사용한다. 
   - 메소드나 하나의 자원 전체에 동기화 걸고 싶을때 사용 
2. 공유 변수에 volatile 를 사용한다. 
   - 하나의 변수, 즉 하나의 자원을 공유자원으로 사용하는 경우 사용하며 double과 float에 주로 사용된다. 

### 데드락 ( 교착상태 )

- 세밀하게 locking(synchronized) 을 하면 발생할 수 있는 현상이다. 

- 모든 스레드들이 다음 작업을 위해 기다리고 있는 현상

  - 즉, 다음 작업의 완료에 필요한 또다른 작업이 있는경우 스레드가 모두 멈춰 동작하지 않는 현상이 발생할 수 있다. 

  ```java
  // Thread 1 
  1. lock(A) 
  4. lock(B) ==> Thread1이 끝나려면 B가 필요한데, Thread2에서 B가 잠겨 Thread2 가 끝날때까지 기다려야한다. 
      
  // Thread 2
  2. lock(B)
  3. lock(A) ==> A가 잠겨있어 Threa1의 A 사용이 끝날때까지 기다려야한다. 
  ```

### 데드락 발생 조건 4가지.

- 다음 4가지 조건을 만족하는 경우 데드락이 발생할 수 있다. 

1. **상호 배제** 
   1. 하나의 자원이 한번에 하나의 스레드에 의해서만 사용가능한 경우
2. **점유와 대기** 
   1. 스레드가 자원을 보유한 상태로 추가적인 자원을 기다리는 경우
3. **비선점 할당**
   1. 다른 스레드가 이미 보유중인 자원을 강제로 빼앗아 사용하는 경우 
4. **순환 대기**
   1. 여러개의 스레드가 서로가 가진 자원을 기다리는 순환형 구조를 이루는 경우 

- 결론
  - 위 4가지 조건 중 하나라도 만족하지 못하게 하면 데드락은 발생하지 않는다. 
  - **순환 대기**를 막는것이 가장 간단하게 예방하는 방법이다.

### 데드락 해결 방법

1. 순환 대기를 막는다. 
   1. 락킹 순서를 맞춰준다고 생각하면 된다. 
   2. A가 락킹 되었을 때, 다른곳에서 락킹된 A를 사용하지 않는것 
   3. 이 방법은 프로젝트가 커지면 사용하기 힘듬.
2. 데드락을 감지하는 감시장치를 사용

