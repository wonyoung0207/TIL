# Day4

---

> 클래스 , 패키지 
>
> 타입 형변환
>
> 오버라이딩 
>
> Up-casting, down-casting
>
> 다형성 
>
> 3-10

## 패키지

- 클래스들의 그룹화를 뜻한다. 
- 패키지를 사용하는 이유는 **클래스 이름에 대한 유일성을 보장**할 수 있기 때문이다. 
- 같은 패키지 안에 있는 클래스는 import 가 필요하지 않지만, 다른 패키지의 클래스를 사용하기 위해서는 import 키워드를 이용해 해당 패키지의 클래스를 가져와야한다
- java.lang 패키지는 default 로 설정되어있어 import하지 않아도 사용할 수 있도록 했다. 
  - String, System 등 같이 많이 사용되는 클래스들을 넣어놓은 패키지이다. 


---

## 상속

### 정의

- 연관있는 클래스들에 대해 공통적인 구성요소를 정의하고 대표하는 클래스를 정의하는 것 

### 특징

- 부모클래스의 모든 자원 (속성, 메소드) 를 사용할 수 있다. 
- 하지만 부모 클래스의 private에는 접근할 수 없다. 
  - 상속받은 클래스는 상속 클래스를 **확장하여 구현**한다. 
  - **오버라이딩** : 상속받은 메소드를 재정의 해서 사용할 수 있다. 
- 자식클래스가 인스턴스화 될 때 기본적으로 **부모 클래스의 디폴트 생성자를 호출**한다. 
  - 이때 부모 클래스의 어떤 생성자로 생성해야하는지가 중요해진다. 
  - 따라서 자식클래스의 생성자에서 **super() 메소드**를 통해 부모 클래스의 원하는 생성자를 호출 할 수 있다. 

### 상속관계의 초기화 과정 

- 자식 클래스를 인스턴스화(new 해서 생성) 하면 **부모 클래스 또한 객체의 인스턴스화가 진행**된다. 
- 이때 **부모클래스의 인스턴스화가 먼저 진행**된다. 

---

## 메소드 재정의 ( 오버라이딩 )

### 정의 

- 상속관계에 있을 때 자식 클래스에서 메소드를 확장하거나 다시 정의하는 것 

- **상속받은 메소드의 헤드(반환타입, 메소드명, 파라미터)를 동일하게 하여 재정의** 한다. 

  - 이때 **달라질 수 있는 것**은 **메소드의 바디와 접근지정자** 이다. ( 접근지정자의 범위는 상위 클래스보다 넓거나 같아야한다. )
    - 따라서 package 를 바꾸려면 protected 와 public 으로만 바꿀수 있다. 
  - 메소드의 헤드는 달라지지 않는다. 


### 접근지정자 범위 순서 

1. public
2. protected
   - package의 접근권한을 포함하고 있다. 
3. package
   - package안에서만 접근권한을 가진다. 
4. private

### super 키워드 사용 

- 오버라이딩된 메소드가 아닌 부모 클래스의 메소드를 호출 하고 싶은경우 사용한다. 

- 메소드의 기능을 확장할 경우 사용하는 방법  

  - super.draw() : 부모 클래스의 draw를 호출 

  - 오버라이딩된 메소드에서 부모 클래스의 draw가 호출된 후 오버라이딩된 메소드의 다음 내용들이 호출된다. 

    ```java
    class shape{
        int x ;
        int y;
        public shape(int x, int y){
            this.x = x;
            this.y = y;
        }
        public int add () {
            return x + y;
        }
    }
    
    class circle extends shape {
        public circle(int x, int y){
            super(x,y);
        }
        public int add () {// 오버라이딩
            int c = super.add(); // 메소드의 기능을 확장하는 방법 ( 부모 클래스의 add 호출 후 연산실행 )
            return c + PI;
        }
        public int getArea(){
            return x * y;
        }
    }
    ```

---

## 객체간 타입 형변환

### 강한타입 언어

- 데이터의 타입을 미리 정의하고 사용해야한다. 
- java,C
- 장점
  - 프로그램 개발에 있어 **명확함과 구체성을 제공**한다. 

### 느슨한 타입 언어

- 데이터의 타입을 미리 정하지 않아도 컴파일과정에서 정해진다. 
- JavaScript
- 장점
  - 프로그램의 **유연성 제약에서 자유롭다.** 

### 타입 캐스팅 필요한 경우 

- 타입캐스팅을 하면 그때만 ( 그 줄에서만 ) 타입이 잠시 변하는 것이다. 

```java
double b = 10.0;

//L value 의 타입이 int이고, R value의 타입은 double 이다. 
int a = b
// 따라서 R Value의 타입을 L Value에 맞춰야 하기 때문에 10.0을 int로 타입캐스팅 해줘야한다. 
int a = (int) b ;

// 이 다음에 b를 사용하면 b는 int가 아닌 double 타입이다. 
// 타입캐스팅은 그 당시에만 타입이 잠시 변하는 것 이다. 
```

### Up-Casting 과 Down-Casting

- Java의 강한 타입의 언어특징이 예외인 부분이 있다. 그게 바로 업캐스팅이다. 

- 업캐스팅이란, 자식 클래스가 부모 클래스 타입으로 참조되는 경우이다. => (조건은 상속관계에 있어야 한다. )

  - **자식이 부모 모습을 띄게 하는 것** 

- 다운캐스팅이란, 부모 모습을 하고있는 인스턴스를 자식 모습으로 바꾸는 것을 말한다. 

  - 다운캐스팅이 가능하기 위해서는 조건이 있는데, 반드시 업 캐스팅이 진행 된 객체에 한해서만 가능하다. 
  - 따라서 **부모가 자식모습을 띄고있을 떄 다시 돌려놓는 기능을 한다.** 

  ```java
  class MainClass{
      public static void main(String[] args){
          shape shape = new circle();//  업 캐스팅 => 원래는 강한 타입 언어의 특징으로, 타입 캐스팅을 해줘야 하지만 이때만큼은 자동으로 캐스팅이 진행된다. 
          
          circle c = (circle) shape ;// 다운 캐스팅 
          
          circle x = new shape() ; // Error : 다운캐스팅이 일어나기 위해서는 조건이 있다. ( 부모가 자식 모습을 띄고 있는 객체에 한해서만 다운캐스팅이 가능하다. )
      }
  }
  ```


### **업캐스팅 했을 경우의 메소드 호출** 

- 자식 타입을 부모 타입으로 업캐스팅 했을 경우, 형태가 부모 타입이 되기 때문에 업캐스팅 되기 전 객체인 자식 타입의 메소드들은 가려져 호출할 수 없다. 
- 따라서 **업캐스팅 경우** 자식 객체를 참조하는 것이 아닌 , **Heap 영역**에 있는 **자식 타입객체 안에서 생성된 부모 타입을 가리키게 되어** 자식 객체의 **확장된 영역은 가려지게 된다.** 
- 오버라이딩된 메소드 호출 시 **자식 클래스의 오버라이딩된 메소드가 호출**된다. 

```java
class MainClass{
    public static void main(String[] args){
        shape shape = new circle();
        shape.add(); // 호출 가능
        shape.getArea() ; // Error : 호출 불가. getArea() 는 자식 객체에 있는 메소드 이므로, 업캐스팅 된 shape 변수로는 호출 할 수 없다. 
        // shape 변수는 stack 영역에 있어, heap영역에 있는 circle 인스턴스 안에 있는 shape 인스턴스를참조하게 된다. 
        // 업캐스팅이 아닌 circle형태의 변수였다면, heap 영역에 있는 circle 인스턴스를 참조할 것이다. 
        
        // 다운 캐스팅
        circle c = (circle)shape;
        // 이렇게 되면 c는 다시 heap 영역에 있는 circle 인스턴스를 참조하게 된다. 
    }
}
```

---

## 다형성

### 정의

- 하나의 객체가 다양한 형태로 처리될 수 있는 특성
- 자식객체들이 같은 부모로 부터 메소드를 상속(오버라이딩) 받아 다양한 기능을 하는 것 

### 다형성 조건

- **상속, 재정의 메소드, 객체간 형변환( 업캐스팅 )** 세가지 조건 모두를 만족했을 경우에만 **다형성**이라고 할 수 있다. 

```java
Shape[] shapes = new Shape[5];
shapes[0] = new Rectangle();
shapes[1] = new Line();
shapes[2] = new circle();

// 다형성 
for(Shape s : shapes){
    s.draw();// 부모 타입으로 업캐스팅된다. 따라서 업캐스팅 된 변수의 오버라이딩 메소드를 호출하면 확장한 자식 타입 객체의 오버라이딩 메소드가 호출된다. 
} 
```

### instanceof 연산자 

- **객체의 타입을 확인하는 연산자로**, 같은 타입의 객체인지 확인하고 상위 클래스를 상속받은 클래스라면 true를 반환한다.  
  - **형변환이 가능한지 체크**할 때 사용한다. 
- 사용 형식 
  - '객체 + instatnceof  + 클래스 '
  - 객체는 클래스에 속해( 상속해 ) 있는 클래스 인가?
- instatnceof 키워드를 지양해야 하는 이유 
  - 자바의 특징인 캡슐화가 깨진다. 
    - 캡슐화란, 객체의 행위를 외부의 다른이가 사용하거나 보지 못하도록 숨기는 것을 뜻한다. 
    - instanceof를 사용하면 외부의 객체가 그 정보를 알야아하기 때문에 지양하는 것이 좋다. 

```java
for(Shape s : shapes){
    if(s instanceof Rectangle){ // s는 Rectangle 클래스와 타입이 같은지 
        ((Rectangle)s).drawRectangle();// s를 다운캐스팅 한 후 자식 클래스에 있는 메소드를 호출 
        // 같은 풀이 
        Rectangle r = (Rectangle) s;
        r.drawRectangle();
    }
    if(s instanceof circle){
        ...
    }
} 

// 간단한 풀이
for(Shape s : shapes){
    s.draw(); // 상속받은 각각의 객체에서 오버라이딩 된 다른 형태의 메소드가 호출된다. 
}
```



