

# Day8

---

> Java8 이후 변경내용 
>
> 람다식
>
> 스트림 API
>
> 5-6강 

## Java 8 변경사항들 

1. 인터페이스의 **디폴드 메소드** 추가 
2. **람다식**을 통한 함수형 프로그래밍
3. **스트림 API** 추가 

---

## 인터페이스 

### 한계

- 특정 인터페이스를 구현한 구현 클래스들은 명시된 기능들을 구현할 수 있게된다. 
- 하지만 한번 베포된 인터페이스들은 이후에 해당 인터페이스를 상속받아 구현한 클래스들이 많기때문에 수정이 어렵다는 단점을 가진다. 

### 특징

1. 상수만 선언할 수 있다. (final static )

2. 추상 메소드만 정의할 수 있다. (abstract)

3. 인터페이스를 구현할 클래스는 해당 메소드를 재정의 하거나 추상 클래스여야 한다. 

4. 모든 필드와 메소드는 public 이다. 

5. 중첩하여 인터페이스를 선언할 수 있다. 

6. static 메소드를 선언할 수 있다. => java 8 이후

7. 디폴트 메소드를 선언할 수 있다. (default) => java 8 이후

   - 온전한 메소드로, 구현 클래스에서 재정의를 하지 않아도 된다. 

     ```java 
     // default 메소드 
     public interface Message{
         String LANGUAGE = "KOREAN"; // public static fainal => 상수필드 
         
         String showMessage(); // public abstract => 추상 메소드 
         
         default String getLanguage(){ // public => default 메소드 
             return Message.LANGUAGE;
         }
     }
     ```

---

## 함수형 프로그래밍

### 정의 

- **함수들의 집합**으로 프로그래밍 하는 것 
- **선언형 프로그래밍을 따르는** 대표적인 프로그래밍 패러다임 이다. 

### 특징

- **순수함수**
  - 함수의 수행결과는 오로지 입력(매개변수 )에 따라 결정된다. 
    - 따라서 **입력값이 들어오면 출력값이 외부 참조값에 의해 달라지지 않는 함수** 
  - 함수의 실행에 따른 부수 효과가 발생하지 않는다. 
    - 함수 실행시 외부에 변경이 일어나지 않는 함수 
- **일급객체**
  - 함수를 변수 혹은 특정 데이터 구조에 담을 수 있다. 
  - 함수를 파라미터를 통해 전달할 수 있고, 결과로 반환할 수 있음
- **불변의 자료구조 or 영속 자료구조** 
  - 특정 변수 / 객체의 자료를 직접 변경하지 않고 새로운 인스턴스를 통해 의도하지 않는 변경을 방지 

### 형태 

- 우선 명령형 프로그래밍과 선언형 프로그래밍에 대해 알아야 한다. 
- **명령형 (imperative) 프로그래밍**
  - 특정 기능을 수행하기 위해 **어떻게(how)** 에 집중하는 방식 
- **선언형 (declarative) 프로그래밍**
  - 특정 기능을 수행하기 위해 **무엇(what)** 에 집중하는 방식 => 어떤 함수를 사용할 것인지 함수로 나열
  - **코드의 가독성이나 이해가 편해진다.** 

```java
List<Integer> list = Arrays.asList(1,2,3,4,5,6,7,8,9);
int result = 0;

// 명령형 프로그래밍 
for(int n : list){
    if(n % 2 == 0){
        result += n;
    }
}

// 선언형 프로그래밍 
result = list.stream()
    .filter(n -> n % 2 == 0)
    .mapToInt(Integer :: intValue)
    .sum();
```

### 중첩 클래스

- 클래스 안에 클래스가 선언되어있는 형태의 클래스.
- Static , Non - Static 으로 나뉜다. 
- Static 
  - 클래스 안에 static 으로 클래스가 정의되어 있는 형태 
- Non - Static 
  - 멤버 클래스 : 필드처름 클래스를 선언한 경우 ( 밖에 클래스가 정의 되어야 만들어짐 )
  - 로컬 클래스 : 특정 메소드 안에 클래스가 정의되어 있는 형태 ( 메소드가 호출되었을 때 클래스가 정의되는 형태 )
  - 익명 클래스 : 메소드 안에 클래스가 선언되어 있는데, 이때 클래스 이름이 선언되어있지 않은 형태 

---

## 람다 표현식 

### 정의

- 함수의 파라미터로 함수를 전달한다. 
- 익명 클래스를 간소화 하기 위해 사용함 

### 특징

- 불필요한 코드를 줄이고 코드의 이해를 돕는 장점을 가짐 

- 특정 클래스에 종속되지 않는다. 

- 함수 자체를 전달 인자로 보내거나 변수에 저장하는 것이 가능 

- 람다 표현식을 받기위해선 **함수형 인터페이스** 타입을 알아야 한다. 

  - 인터페이스의 경우 추상 메소드가 1개 이상 있어야 한다. 

    ```java
    // Consumer 라는 함수형 인터페이스로 람다 표현식을 담을 수 있다. 
    Consumer<String> con = s -> sysout(s);
    
    con.accept("java")// con변수가 참조하는 람다표현식을 호출하게 된다. 
    ```

- 따라서 이제는 매개변수로 function 즉, 람다표현식을 받을 수 있다. 이때 타입이 필요하게 된다. 

  - 타입은 함수형 인터페이스로, Predicate<> , Consumer<>, Function<>, Supplier<> 인터페이스 등이 있다. 
  - 해당 인터페이스는 java가 제공한다. 

### 형태 

- **() -> { ... }** 
  - () : 파라미터 => 실행문에 보낼 데이터를 써줌 
  - -> : 화살표
  - { ... } : 실행문 
- 화살표를 기준으로 왼쪽은 파라미터, 오른쪽은 실행문이 온다. 

```java
// 일반 표현식 
Runnable run = new Runnable() { // 익명 클래스 
	@Override
    public void run(){
        // 
    }
}
for(String str : list){
    System.out.println(str);
}

// 람다 표현식 
Runable run = () -> { }
list.stream().forEach( (String str ) ->  System.out.println(str)); // 타입추론으로 인해 파라미터의 타입을 생략할 수 있다. 
// 같은 결과 
list.stream().forEach( str ->  System.out.println(str));
list.stream().forEach( System.out :: println);

```

