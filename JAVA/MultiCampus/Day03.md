# 3일차

> 자바의 메모리 관리( stack , heap )에 대해 배운다.
>
> Scanner 에 대해 배운다. 



1. class가 자바 머신(JVM)에 의해 실행되면 메모리에 자바 영역이 잡힌다. 
   + 메모리 영역은 크게 **code, Stack, Heap** 으로 나뉜다. 
   + **Code **
     + 클래스의 정보가 code영역으로 들어간다. 
   + **Stack**
     + 변수값이 stack 으로 들어간다 => 후입선출 => 함수의 호출과 관계되는 변수와 매개변수가 저장되는 영역 -> 함수 호출이 완료되면 소멸한다. (일반 변수와 지역변수가 들어간다. )
     + 매우 빠른 액세스. 
     + 공간이 cpu에 의해 관리, 
     + 지역변수만 저장,
     + 크기에 제한 
     + 높은 주소에서 낮은 주소의 방향으로 할당 
   + **Heap**
     + 사용자가 직접 관리해야하는 메모리 영역으로 사용자에 의해 공간이 동적 할당되고 해제된다. ( 문자열과 배열이 대표적임 )
     + 상대적으로 액세스 느림
     + 사용자가 공간을 할당하고 해제해야 함 
     + 변수가 전역적임 
     + 크기에 제한 없음
     + 낮은 주소에서 높은 주소의 방향으로 할당 
   + 프로그램이 끝나면 들어온 순의 역순으로 삭제되고 자바 영역이 삭제된다. 
   + 문자열과 배열의 경우 값은 heap 영역에 저장이 되고, stack 영역에는 해당 값의 heap 주소가 들어가있다. 
   + 가비지 컬랙터 : stack 영역과 heap 영역의 연결이 끊어진 데이터를 heap 영역에서 자동으로 삭제해준다. 
   + Heap 영역에 저장된 값은 변경할 수 없다. 따라서 해당 값을 바꾸기 위해서는 값을 삭제시키고 다시 공간을 할당받는다. 이때 바뀌기 전 주소의 데이터는 가비지 컬렉터에 의해 삭제된다. 
2. 메모리 주소 얻는 방법
   + String s1 = “ABC”  와 String s2 = “ABC” 는 같은 주소를 가진다. -> ABC의 주소에 있는 값을 바꾸면 s1과 s2 둘다 바뀐다. 
   + String s3 = new String(“ABC”) -> 이렇게 하면 다른 주소를 가지는 ABC를 만들 수 있다. 
   + System.out.println(System.identityHashCode(s3)) => 이것을 통해 메모리 주소를 확인할 수 있다. 
     + S1과 s2는 같은 메모리 주소가 나올것이다. 
3. 타입 확인하기
   + A.getClass().getSimpleName(); => A 객체의 타입을 확인할 수 있다. 
4. Eval() 
   + 자바에는 **문자열을 계산해주는 함수**는 따로 존재하지 않는다. 
   + 따라서 **일일히 if문이나 switch 문으로 계산**해줘야한다. 