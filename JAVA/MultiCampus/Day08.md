# 8일차
---

> 객체간의 관계를 파악한다. 
>
> 접근 지정자에 대해 정리한다. 
>
> 상속에 대해 공부한다. 



1. 객체간의 관계

   1. **집합 관계** : 완성품과 부품의 관계 
      + 자동차와 엔진,타이어 의 관계
   2. **사용 관계** : 객체가 다른 객체를 사용하는 관계
      + 사람과 자동차의 관계
   3. **상속 관계** : 종류 객체와 구체적인 사물 객체 관계
      + 자동차와 기계와의 관계 -> 코드를 재사용, 유지보수에 용이하다. 

2. 오버로딩 vs 오버라이딩

   + **오버로딩 **
     + 같은 이름의 생성자 또는 메소드에서 매개변수 갯수, 타입을 다르게 하여 서로 다른 기능을 할 수 있도록 하는 것 
   + **오버라이딩** (재정의)
     + 상위 클래스의 메소드와 같은 이름으로 메소드를 만들어 상위 클래스와는 다른 기능으로 사용하는 것 

3. Static

   + 변수
     + static으로 선언한 변수는 해당 클래스로 생성된 모든 객체가 sattic 변수의 **메모리를 공유**한다. 
   + 메모리
     + static 메모리는 인스턴스(객체) 의 생성이 없이도 호출할 수 있다. 
   + heap 영역이 아닌 **static 영역이 따로 존재**하여 할당된다. 
   + 하지만 static영역은 garbage collector의 관리 영역 밖이기 때문에 프로그램 종료시까지 메모리가 할당된 채로 존재한다. 

4. 패키지

   + 같은 패키지가 아니라면 해당 객체를 사용하기 위해서는 import를 해야한다. 
   + 하지만  java.lang 패키지는 기본으로 제공되기 때문에 import 하지 않아도 된다. 

5. 접근 지정자

   1. **디폴트  **
      + 같은 패키지 내에서만 접근이 가능하다. 
   2. **private **
      + 동일 클래스 내에서만 접근이 가능하다. 
   3. **protected **
      + 같은 패키지 내에서 접근이 가능하고, 상하 상속관계가 있을때만 접근이 가능하다. 
      + 패키지가 달라도 상속 관계이면 접근 가능 
   4. **public**
      + 다른 패키지에 있더라도 모든 접근을 허용

   + 클래스의 접근지정자는 public 과 default 만 가능하다. 

6. 상속 (generalization)

   + 상위 클래스에 정의되어있는 변수나 메소드를 사용할 수 있다. 
     + 코드를 재사용할 수 있다. 
   + super()로 상위 클래스의 생성자를 부른다. 
   + super.toString() 하면 상위 toString 을 출력할 수 있다. 
   + **generalization  **
     + ex )  사원(상위) <= 매니저(하위) 
       + **매니저를 일반화 시킨것이 사원**이다.
   + 재정의 (오버라이딩) 을 통해 상위 내용을 하위에서 재정의 할 수 있다. 
   + 상속관계 상위의 메소드 호출 방법
     1. super.getSalary() 
     2. getSalary()
   + 상속관계 배열 응용
     + 상위클래스의 객체에 하위 클래스의 객체를 담을 수 있다. 

7. 객체 타입 확인

   + **instanceof** 사용
   + 배열에 들어가있는 객체 중에서 뒤에오는 객체 형태를 확인 
   + 주로 상속관계에서 부모 객체인지 자식객체인지 확인하는데 사용된다. 
     + ex) if( arr[i] instanceof Manager)  => arr[i] 번쨰 객체의 타입이 Manager 이라면 실행 

8. 상속 이용한 Company 만들기 

   1. 사원 별 객체를 생성 하고 출력 하시오
   2.  모든 사원의 연봉 정보를 출력 하시오
   3. 모든 사원에게 인센티브를 지급 하고자 한다.
   4. 지급 시 각 사원 별 지급 금액이 다르다.
   5. ex) 인센티브 100만원 지급 시 일반사원은 50%지급,비서는 60% 지급,영업은 영업 목표 대비 ,성 목표에 따라 인센티브 금액 결정,관리자는 100% 지급
