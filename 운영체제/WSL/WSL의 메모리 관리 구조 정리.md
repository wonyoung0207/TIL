# WSL(Windows Subsystem for Linux)의 메모리 관리 구조 정리

---

>

## 학습 개요 

- Window 환경에서 리눅스 시스템을 이용하기 위해 WSL 을 사용했었다. 
  - 계속해서 개발하던 도중 컴퓨터의 성능문제인지 애플리케이션이 너무 느려지기 시작했다. 
  - 이유를 찾다가 WSL 의 메모리 관리 문제가 성능에 영향을 끼친다는 것을 알게 되었다. 

## 해결방법

- wsl 메모리 수동 캐시 해제 (buff/cache 해제)
  - `buff/cache` 메모리가 해제되고 `free` 용량으로 반납된다. 
  - 몇분 뒤 `free` 용량중 일부가 window 메모리로 반납 



## 문제 발생 이유 

- 메모리가 작은 노트북을 사용 (16GB)
- **WSL 이 메모리를 모조리 가져다가 점유 ( 어플리케이션은 잘 동작 하지만 Window 시스템(브라우저 등등)이 너무 느려짐 )**

##  

## WSL의 기본 구조

- **WSL2**는 **실제 Linux 커널을 포함한 경량 가상 머신(Hyper-V 기반 VM)** 으로 작동함.
  - 이때 Windows 프로세스 목록에서 보이는 `VmmemWSL.exe`가 바로 WSL2 가상 머신의 메모리/CPU 자원을 관리하는 프로세스임.
  - 즉, **WSL2 = Windows 위에 떠 있는 Linux 가상머신**이며, Linux가 사용하는 모든 메모리는 `VmmemWSL`이 사용 중인 메모리로 표시된다.



## WSL 메모리

##### 1. 구조

- 다음 명령어를 통해 메모리 사용 구조를 볼 수 있다. 

  ```bash
  free -h
  ```

  ```bash
                 total        used        free      shared  buff/cache   available
  Mem:            15Gi       7.9Gi       6.0Gi       3.5Mi       1.9Gi       7.6Gi
  Swap:          4.0Gi          0B       4.0Gi
  ```

| 필드           | 의미                    | 상세 설명                                                    |
| -------------- | ----------------------- | ------------------------------------------------------------ |
| **total**      | 총 메모리 용량          | 시스템에서 사용 가능한 전체 물리 메모리(RAM) 크기.           |
| **used**       | 현재 사용 중인 메모리   | 커널이 실제로 사용 중인 메모리(앱 + 커널 + 캐시 포함). “사용 중”이라도 캐시 메모리는 곧 재사용 가능함. |
| **free**       | 완전히 비어 있는 메모리 | 현재 아무 프로세스나 캐시도 사용하지 않는 ‘진짜 남는’ 메모리. 하지만 리눅스에서는 이 수치가 작아도 문제 아님. |
| **shared**     | 공유 메모리             | 여러 프로세스가 동시에 접근하는 메모리 영역 (예: tmpfs, IPC shared memory). |
| **buff/cache** | 버퍼/캐시 메모리        | 파일 시스템 버퍼, 페이지 캐시 등으로 사용 중인 메모리. I/O 성능 향상을 위해 남는 메모리를 활용하지만, 필요 시 즉시 반환 가능. |
| **available**  | 실제 사용 가능한 메모리 | 새 프로그램이 즉시 사용할 수 있는 메모리 예측치. 캐시·버퍼 중 곧 해제 가능한 영역까지 포함해서 계산됨. |



##### 2. 특징

- `동적 메모리 할당 + 점진 반환` 으로 인해 문제가 생겼었다. 

| 항목                                             | 설명                                                         |
| ------------------------------------------------ | ------------------------------------------------------------ |
| **동적 메모리 할당 (Dynamic Memory Allocation)** | Linux 커널이 필요할 때마다 Windows로부터 메모리를 **점진적으로 요청**함 |
| 공격적인 캐시 정책 (Aggressive Caching)          | I/O 속도를 높이기 위해 남는 메모리를 파일 캐시(buff/cache)로 적극 활용 |
| **즉시 반환하지 않음 (Lazy Reclaim)**            | 한 번 확보한 메모리는 바로 Windows에 돌려주지 않고 일정 시간 보관함 |
| **점진 반환 (Gradual Release)**                  | WSL이 idle 상태가 되면, 일정 주기마다 메모리 일부를 Windows로 반납함 |



#### 3. 메모리 자동 반환 안하는 이유

 1. Linux 커널 설계 철학

- Linux 커널은 “**남는 메모리는 낭비다**”라는 원칙을 가짐.
- 사용하지 않는 RAM을 **파일 캐시, 페이지 캐시, 버퍼** 등으로 적극 재활용.
- 따라서 “available”이 많아도 커널은 일단 잡고 있는 게 성능에 유리하다고 판단함.

2. Hyper-V 동작 특성

- WSL2는 Hyper-V 기반 경량 VM으로 동작하며,
   Windows와의 메모리 교환은 **동적 메모리 관리(Dynamic Memory Balancer)** 를 통해 이루어짐.
- 이 밸런서는 성능 유지를 위해 **즉시 회수하지 않고**,
   “가상머신이 일정 시간 동안 메모리 요청을 안 할 때” 천천히 회수함.
- 즉, **“성능 우선, 회수 후순위”** 정책.



##### 4. available 메모리 반납 주기 

- WSL이 **idle 상태**(즉, CPU 사용률과 I/O 활동이 거의 없음)가 되면 커널 내부의 `kswapd` / `balloon driver` 가 작동해 메모리 페이지를 Windows로 돌려줌.
- 이 과정은 **즉시적이지 않고, 몇 분 단위의 주기적 GC처럼 점진적**으로 일어남.
- 따라서 시간이 지나면 `VmmemWSL` 프로세스의 메모리 사용량이 서서히 감소한다.



## 메모리 반환을 즉시 강제로 일으키는 방법

##### 1. WSL 에서 수동 캐시 해제

- WSL 내부에서 커널 캐시를 비우면 반환 대상 메모리가 늘어남.
  - `sync`: 디스크 버퍼를 모두 flush
  - `drop_caches`: Linux 내부의 캐시 해제 (파일 캐시, 디렉토리 캐시 등 해제 )
    - `buff/cache` 가 `free` 쪽으로 전환됨  (“아직 Linux VM이 그 메모리를 확보하고 있다”고 보기 때문)
      - **즉시 반환하려면** `wsl --shutdown` 필요
    - **이후 몇 분 내에  free 영역을 Windows로 점진적으로 반환** 

```bash
sudo sync
sudo sh -c 'echo 3 > /proc/sys/vm/drop_caches'
```

##### 2. WSL 완전 종료

- WSL 프로세스를 완전히 내리면 `VmmemWSL`이 즉시 사라지고, 확보했던 메모리도 전부 Windows에 반환됨.
  - **실행하면 `free`, `available`, `buff/cache` 포함한 모든 메모리가 Windows에 완전히 반납**
  - 단, Docker Desktop 등 WSL을 백엔드로 사용하는 앱이 있으면 자동으로 다시 올라올 수 있음.

```bash
wsl --shutdown
```

#####  3. `.wslconfig`로 상한 설정

- Windows 사용자 폴더(`C:\Users\<username>\.wslconfig`)에 설정 추가:
  - `memory`: WSL이 사용할 수 있는 **최대 메모리 한도**
  - `swap`: 메모리 부족 시 사용할 디스크 공간
  - 이 설정은 반환 타이밍에는 영향이 없지만, **최대 점유 한도**를 강제해 과도한 메모리 사용을 방지할 수 있음.

```bash
[wsl2]
memory=8GB
swap=2GB
processors=4
localhostForwarding=true
```