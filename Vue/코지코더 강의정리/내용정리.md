# Vue js2 기초 익히기 기본강좌

---

>[코지코더 vuejs2 기초강좌](https://www.youtube.com/watch?v=gZBKGn0wQXU&list=PLB7CpjPWqHOtYP7P_0Ls9XNed0NLvmkAh&index=1)

## 01. 뷰 인스턴스 생성 

- new Vue({ }) 의 형태로 인스턴스를 생성하고 태그에 연결한다. 

```vue
<body>
    헬로 월드 1
    <div id="app">
        <!-- 뷰 인스턴스 연결하는 곳  -->
        {{ name }}    
    </div>

    <script>
        new Vue({
            // 뷰 인스턴스 생성
            el: "#app", // 연결할 태그 이름 
            data : { // 뷰 인스턴스에서 사용할 데이터 
                name : "wonyoung"
            }
        })
    </script>
</body>
```

## 02 뷰 인스턴스에서 Method 사용

- 키워드가 ' methods ' 라는것에 유의하기 
- 자바스크립트와 동일한 방법으로 함수 사용해줄 수 있다. 
- this라는 곳에 data 에 들어가있는 값이 모두 들어가있기 때문에 바로 사용할 수 있다. 

```vue
<body>
    <div id="app">
        <!-- 뷰 인스턴스 연결하는 곳  -->
        {{ nextYear('hello') }}    
    </div>

    <script>
        new Vue({// 뷰 인스턴스 생성
            el: "#app", // 연결할 태그 이름 
            data : { // 뷰 인스턴스에서 사용할 데이터 
                person : {
                    name : 'wonyoung',
                    age : 28
                }
            },
            methods : { // method 가 아니라 methods 이다. 
                nextYear( a ){ // 자바스크립트처럼 사용하면 됨 
                    // vue가 this라는 곳에 data 에 있는 모든 값들을 넣어준다. 
                    return a + '! ' + this.person.name + '는 내년에 ' + (this.person.age + 1) + '살 입니다. ' ;
                },
                otherMethod : function(){// 이렇게 function 을 써서 메소드 구현할 수도 있다. 하지만 위에서 사용한게 더 간단함 
                    this.nextYear();
                } 
            }
        })
    </script>
</body>
```

## 03 데이터 바인딩

- " v-bin : " 를 이용해서 데이터를 바인딩 할 수 있다. 
  - 여기서 "v-bind" 를 생략하고 " : " 만 써서 사용할 수도 있다.

```vue
<body>
    <div id="app">
        <!-- <input v-bind:type="type" v-bind:value="inputData"> -->
        <!-- vue에서 지원하는 기능으로인해 v-bind 라는 문구를 생략하고 : 만 써서 이용가능  -->
        <input :type="type" :value="inputData">
        <a :href="myGithubConnection('wonyoung0207')"> 내 깃주소 연결 
    </div>

    <script>
        new Vue({
            el: "#app", 
            data : {
                inputData : '값을 넣어주세요. ',// 데이터 바인딩 시 사용할 변수이름과 값
                type : 'text', // 데이터 바인딩
                github : 'https://github.com/',
            },
            methods : { 
                myGithubConnection(myGithubAdd){
                    return this.github + myGithubAdd;
                }
            }
        })
    </script>
</body>
```

## 04. 이벤트 바인딩 

- " v-on : " 을 사용해서 이벤트를 바인딩 시킨다. 

  - 이때 **이벤트 수식어**기능이 있어 preventDefault() 같은 이벤트 메소드를 쉽게 사용할 수 있다. 
  - "v-on : " 을 **@ 로 대체**해서 사용할 수 있다. 
  - **태그안에서 메소드 호출시 ' ( ) ' 를 붙이지 않아도 된다.** 

- **이벤트 수식어 종류**

  - `.stop` : 이벤트 전파 중지 

    ```html
    <a @click.stop="doThis"></a>
    ```

  - `.prevent` : submit 이벤트가 더이상 페이지 리로드 하지 않게함 

    ```html
    <form @submit.prevent="onSubmit"></form>
    ```

  - `.self` 

  - `.capture` 

  - `.once`

  - `.passive`

- [**입력키 수식어** 종류](https://ko.vuejs.org/guide/essentials/event-handling.html#event-modifiers)

  - 키보드 이벤트를 수신할 때 , 특정키를 확인해야하는 경우가 있다. keyup, keydown 같은 이벤트를 쉽게 이용하도록 키 수식어를 지원한다. 

  - `.enter`

    ```html
    <!-- Alt + Enter -->
    <input @keyup.alt.enter="clear" />
    <!-- Ctrl + Click -->
    <div @click.ctrl="doSomething">시작하기</div>
    ```

  - `.tab`

  - `.delete` ("Delete" 및 "Backspace" 키 모두 캡처)

  - `.esc`

  - `.space`

  - `.up`

  - `.down`

  - `.left`

  - `.right`

  - `.ctrl`

  - `.alt`

  - `.shift`

  - `.meta`

```vue
<body>
    <div id="app">
        {{ year }}
        <br>
        <button v-on:click="addYear"> 날짜 더하기 </button>
        <button v-on:click="minusYear"> 날짜 빼기 </button>
        <br>

        <form v-on:submit.prevent="submit">
            <input type="text">
            <!-- submit 의 특징은 데이터를 보내고나면 화면을 리로드 시킨다는 것이다. 따라서 preventDefault 를 false로 해줘야한다. -->
            <!-- vue에서는 .prevent 라는 이벤트 수식어를 통해 더 쉽게 사용할 수 있다.  -->
            <button type="submit"> submit </button>
        </form>
    </div>

    <script>
        new Vue({
            el: "#app", 
            data : {
                year : '2023',
            },
            methods : { 
                addYear(){
                    this.year++;
                },
                minusYear(){
                    this.year--;
                },
                submit(){
                    alert('123');
                },
            }
        })
    </script>
</body>
```

## 05 양방향 바인딩

- 양방향으로 데이터 바인딩을 할 떄 양방향 바인딩을 사용한다. 
  - form 에서 많이 사용된다. 
- 양방향 데이터 바인딩이란, 메모리의 데이터가 변경되면 **화면에 적용**되고, 화면의 데이터가 변경되어도 **메모리에 있는 데이터를 변경**하는것이다. 즉, **화면과 메모리 둘다에서 데이터의 변화가 일어나는 것**을 말한다. 
  - 예를들어 **단방향**은 데이터가 변경되었을 때 화면에 해당 내용이 적용되는것을 뜻하는 반면, 양방향은 화면의 데이터 변화를 통해서 메모리에 있는 데이터또한 변경되는것을 뜻한다. 
- **" v-model " 키워드**를 사용하면 양방향으로 데이터가 연결되어 처리된다. 

```vue
<body>
    <div id="app">
        <form v-on:submit.prevent="submit">
            <!-- 노가다 양방향 데이터 바인딩 ( 이벤트이용 ) -->
            <input type="text" :value="text" @keyup="updateText"><br>
            <!-- <input type="text" :value="text" v-on:keyup="updateText"><br> 위와 같은 결과냄 -->
            {{ text }}<br>

            <!-- 더 쉬운 양방향 데이터 바인딩  (v-model 키워드 사용 )-->
            <input type="text" v-model="text"><br>
        </form>
    </div>

    <script>
        new Vue({
            el: "#app", 
            data : {
                text : '',
            },
            methods : { 
                updateText(event) {
                    this.text = event.target.value; // event 발생시 생성되는 객체로, event 안에는 발생한 이벤트와 관련 정보들이 들어있다. 
                },
            }
        })
    </script>
</body>
```

## 06 Computed 속성

- [Vuejs 공식_computed 캐싱](https://ko.vuejs.org/guide/essentials/computed.html)
- Methods 와 Computed 의 차이점 
  1. 캐싱 차이 
     - 캐싱
       - 한 번 연산해놓은 값을 반복적으로 출력할 때 다시 한번 연산하지 않도록 돕는 기능 
       - computed 에서 캐싱기능을 사용한다. 
     - methods 
       - 처음 new Vue를 호출했을때 실행되는것이 아니라 여러번 호출시에 여러번 실행되면서 값을 반환한다. 
       - 따라서 호출시에 메소드 안에있는 **코드들을 중복으로 실행**해야함 
     - computed
       - 처음 new Vue를 했을 떄 값이 **한번** 생성되어 호출시에 해당 값을 그냥 반환만 하는 형태 
       - 따라서 맨처음 vue 생성시에 값을 이용해 먼저 실행해놓고 값을 반환한다. 
  2. 호출의 차이 
     - methods 
       - 메소드를 호출하기 위해서는 ' ( ) ' 를 붙여줘야 한다. 안붙이면 변수로 인식하기 떄문에 
     - computed
       - ' ( ) ' 를 붙이지 않고 변수처럼 선언할 수 있다. 
- 사용이유 
  1. 메소드보다 빠르다. 
  2. 데이터의 바인딩으로 인해 **computed 안에서 사용한 값이 변경**된다면 computed 를 사용한 부분을 **자동으로 최신 데이터로 업데이트**해줌 

```vue
<body>
    <div id="app">
        <!-- split하면 한글자씩 arr로 저장함. join하면 배열을 이어줌  -->
        노가다 코드 : {{ msg.split('').reverse().join('') }} 
        <br>
        <!-- 메소드 사용시 뒤에 () 를 붙여줘야 함  -->
        methods 이용 : {{ reverseMessage1() }}
        <br>
        <!-- 메소드와 다르게 변수처럼 사용함.  -->
        computed 이용 : {{ reverseMessage2 }}
        <br>
        <button @click="changeMsg"> text 변경 </button>
    </div>

    <script>
        new Vue({
            el: "#app", 
            data : {
                msg : '내이름은 안원영 입니다. ',
            },
            methods : {  // 호출시 실행되며 중복으로 호출해도 함수안의 코드를 계속해서 호출함 
                reverseMessage1(){
                    return this.msg.split('').reverse().join('');
                },
                changeMsg(){
                    this.msg = '텍스트 변경';
                }
            },
            computed : { // 메소드와는 다르게 vue가 생성될 때 한번 실행되고 그 이후에는 값을 가지고있어 함수를 실행하는 것이 아닌 바로 값을 리턴 
                // 만약 computed 안에서 사용된 vue data의 값이 변경되면 , 데이타 바인딩으로 인해 사용된 곳의 데이터들도 전부 변경된다. 
                reverseMessage2(){
                    return this.msg.split('').reverse().join('');
                }
            }
        })
    </script>
</body>
```

## 07. watch 속성

- 데이터를 감시하고 싶을때 사용한다. 
- 형태
  - 감시데이터이름(newVal , oldVal ) 
  - newVal : 변경되서 새로 바뀐 데이터 값
  - oldVal : 변경전 데이터 값 

```vue
<body>
    <div id="app">
        computed 이용 : {{ reverseMessage2 }}
        <br>
        <button @click="changeMsg"> text 변경 </button>
        <br>
        {{ updateData }}
    </div>
    <script>
        new Vue({
            el: "#app", 
            data : {
                msg : '내이름은 안원영 입니다. ',
                updateData : '업데이트 전 ',
            },
            methods : {  // 호출시 실행되며 중복으로 호출해도 함수안의 코드를 계속해서 호출함 
                changeMsg(){
                    this.msg = '텍스트 변경';
                }
            },
            computed : {               
                reverseMessage2(){
                    return this.msg.split('').reverse().join('');
                }
            },
            watch : { // 어떤 데이터를 감시할 것인지 체크 후 해당 데이터가 변경되면 실행됨 
                msg(newVal, oldVal) { // newVal은 새로 바뀐 데이터의 값, oldVal 은 바뀌기 전의 값이 들어간다. 
                    this.updateData = '업데이트 후 ';
                    console.log(newVal, oldVal);
                }
            }
        })
    </script>
</body>
```

## 08. 클래스 & 스타일 바인딩

- 태그의 스타일에 바인딩을 사용할 수 있다. 
  - 클래스를 2개 적용시키기 위해서는 ' , ' 를 사용한다.
  - 클래스 바인딩시 ' :  ' 를 class 앞에 붙여줘야 한다.
  - 클래스 이름에 ' - ' 가 있다면 ' ' 를 사용해 클래스 이름을 묶어줘야 한다.

```vue
<head>
	<style>
        /* 클래스별 스타일 지정  */
        .red {
            color : red;
        }
        .font-bold {
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- 클래스를 2개 적용시키기 위해서는 ' , ' 를 사용한다.  -->
        <!-- 클래스 바인딩시 ' :  ' 를 class 앞에 붙여줘야 한다.  -->
        <!-- 클래스 이름에 ' - ' 가 있다면 ' ' 를 사용해 클래스 이름을 묶어줘야 한다. -->
        <div :class="{ red : isRed, 'font-bold' : isBold }"> Color Text Test </div>
        <button @click="changeText"> 클래스 이용 폰트 스타일 변경하기 </button>
        <br>
        <!-- 태그에 있는 style속성으로 바인딩해서 변경하기  -->
        <div :style="{ color : color, fontSize : size}"> Color and size Change </div>
    </div>
    <script>
        new Vue({
            el: "#app", 
            data : {
                isRed : false, // 클래스에 false를 적용하면 클래스이름으로 지정되지 않는다. 
                isBold : false,
                color : 'red',
                size : '30px',
            },
            methods : {  
                changeText(){ // 해당 메소드 호출시 클래스의 적용을 토글시킬 수 있다. 
                    this.isBold = !this.isBold;
                    this.isRed = !this.isRed;
                }
            },
        })
    </script>
</body>
```

## 09 v-if 와 v-show 이용

- v-if 와 v-else-if , v-else

  - **조건문**에 사용된다. 
  - 조건에따라 설정한 태그 자체가 렌더링 될것인지 안될것인지 결정할 수 있다. 
  - 따라서 false면 태그를 렌더링하지 않아 표시되지 않는다. 

- **template 태그** 

  - **여러개 태그**에 동시에 v-if 적용하고 싶을 경우 

  - template 태그 예제 

    ```vue
    <template v-if="nummber === 1">
    	<div> 1 </div>
    	<div> 2 </div>
    	<div> 3 </div>
    </template>
    ```

- v-if 와 v-show 차이점 

  - 공통점
    - 둘다 화면에 표시 or 표시x 할때 이용한다. 
  - 차이점
    - **v-if**는 조건에 따라 **태그 자체가 렌더링**되어 false면 아예 태그자체를 페이지에 불러오지 않는다(**렌더링 x**). 
    - **v-show** 는 **항상 렌더링** 되어 태그가 표시되지만 show의 값이 false라면 **' display : none ' 을 이용**해 해당 태그가 **화면에 표시되지 않도록 한다**. 
  - 따라서 변화가 많은 경우 v-show를 사용하고, 런타임시 조건이 바뀌지않으면  v-if의 사용을 권장한다. 

```vue
<body>
    <div id="app">
        <button @click="toggle"> Toggle </button>
        <!-- 간단한 if문을 통해 조건문의 결과가 true이면 태그 렌더링 o , false이면 태그 자체를 렌더링하지 않음   -->
        <div v-if="show"> v-if 이용 Show Data </div><br>
        <!-- v-show는 v-if와 다르게 무조건 렌더링 되기 때문에 html파일에 표시된다. 하지만 false일때 'display : none' 을 적용해 태그를 보이지 않게 만드는 것 뿐이다. -->
        <div v-show="show"> v-show 이용 Show Data </div>
        <br>

        <button @click="increase"> add nummber </button>
        <!-- template 태그를 이용해 여러 태그를 묶을 수 있다.  -->
        <template v-if="nummber === 1">
            <div>1</div>
            <div>1</div>
            <div>1</div>
        </template>
        <div v-else-if="nummber > 1 && nummber <= 3">
            <div>1~3 까지 </div>
        </div>        
        <div v-else>
            3초과
        </div>
        <br>
    </div>
    <script>
        new Vue({
            el: "#app", 
            data : {
                show : true,
                nummber : 1,
            },
            methods : {  
                toggle(){
                    this.show = !this.show;
                },
                increase(){b.  ., 
                    this.nummber++;
                }
            },
        })
    </script>
</body>
```

## 10 v-for  이용

- 리스트 렌더링에 사용된다. 
- in-place-patch 로인해 **key 를 바인딩** 해주는것이 좋다. 
- 형태
  - v-for="item in items" 
  - item은 별칭, items는 배열 
  - :key = "item + '-' + item.name"
    - in-place-patch 전략때문에 key를 사용해줘야한다. 

```vue
<body>
    <div id="app">
        <div>
            {{ people[0].name }} {{ people[0].age}}
        </div>
        <div>
            {{ people[1].name }} {{ people[1].age}}
        </div>
        <div>
            {{ people[2].name }} {{ people[2].age}}
        </div>
        <br><hr>
        <!-- p of people 로 써도 됨  -->
        <!-- 이렇게 반복문 하면 고유 key를 설정해주는 것이 좋다.  -->
        <!-- (p, index) in peple  을 사용해서 index도 사용할 수 있다.  -->
        <div v-for="p in people" :key="p.id + ' : ' + name">
            {{ p.name }} {{ p.age }}
        </div>
    </div>
    <script>
        new Vue({
            el: "#app", 
            data : {
                people : [
                    { id : 1, name : 'a', age : 11},
                    { id : 2, name : 'b', age : 12},
                    { id : 3, name : 'c', age : 13},
                ]
            },
        })
    </script>
</body>
```

## 11 여러개의 Vue 인스턴스 생성 

- Vue객체를 변수에 넣어서 다른 뷰에서 컨트롤 할 수 있다. 
- el 을 통해 **Vue를 연결한 태그 안에서만 해당 Vue객체에 구현한 methods 를 사용**할 수있다. 
  - 만약 app 안에 있는 methods 를 사용하고 싶다면 ' div의 id=app ' 으로 되어있는 태그 안에서만 사용할 수 있다. 

```vue
  <div id="app">
        {{ name }}
        <!-- 해당 버튼이 app 태그 안에 있어야 vue 기능을 사용할 수 있다.  -->
        <button @click="updateApp2"> change Text </button>
    </div>
    <!-- vue 객체를 연결시키지 않으면 vue 기능을 사용하지 못한다.  -->
    <div id="app1">
        {{ name }}
    </div>
    <div id="app2">
        {{ name }}
    </div>
    <script>
        const app = new Vue({
            el: "#app", 
            data : {
                name : 'wony1',
            },
            methods : {
                updateApp2() {// this는 vue 자체를 의미한다. 
                    console.log('a')
                    this.name = 'wony1 Update';
                    app2.name = 'wony2 update';
                },
                changeText(){
                    this.name = 'a';
                }
            }
        })
        const app2 = new Vue({
            el: "#app2", 
            data : {
                name : 'wony2',
            },
        })
    </script>
</body>
```

## 12 Vue 컴포넌트 

- 컴포넌트 
  - 사용자 지정 엘리먼트(태그)로,  태그의 명칭을 내가 정해줄 수 있다. 
    - HTML Element를 확장하고 재사용 가능한 형태로 구현하는 것
    - vue 컴포넌트는 하나의 Vue 인스턴스로 본다. 

  - 따라서 무조건 Vue인스턴스 안에서 사용할 수 있는데, 전역/지역 으로 선언하는 것에 따라 다르게 동작하게 된다. 

- 컴포넌트 등록 범위
  - Vue.js 에서는 '전역 / 지역' 으로 컴포넌트의 범위를 나눌 수 있다. 
  - 설계 부분에서 컴포넌트의 범위를 지정해주는것이 중요 포인트이다. 

- 컴포넌트 전역변수
  - 전역등록을하면 안좋은 이유가 컴포넌트를 사용하지 않더라도 최종 빌드에 들어가있어 사용자가 내려받아야할 자바스크립트의 양이 불필요하게 커지게 된다. 

- 컴포넌트 데이터 전달 
  - 컴포넌트 간 데이터를 전달해야 하는 경우가 있는데 부모에서 자식으로 는 `props`를 사용하고, 반대로 자식에서 부모로 전달할 때는 `events($emit)`를 사용한다. 

1. Component 전역변수로 사용 

   ```vue
   <body>
       <div id="app">
           {{ name }}
           <my-buttom> </my-buttom>
       </div>
       <script>
           Vue.component('hello-world',{
               template : '<div> hello world!! </div>'
           })
           Vue.component('my-buttom', {
               // 백틱을 사용하는 이유는 한줄로 사용할 떄는 '' 로 되지만 여러줄일 경우 ``(백틱) 으로 묶어줘야한다. 
               // 또한 Vue.js 2버전에서는 template의 내용이 하나의 태그로 묶여있어야 에러가 나지 않는다. 
               template : `
               <div>
                   {{name}} <br>
                   <button @click="changeText" > change </button> 
                   <hello-world> </hello-world>
               </div>
               `// hello-world 라는 컴포넌트를 안에서 사용할 수 있다.
               ,
               // vue 인스턴스의 data 처럼 object 형식으로 사용하면 안된다. 
               // 왜냐하면 data를 참조형태로 가져오기 때문에 데이터 변환시 다른곳에도 영향을 끼치게된다.
               // 따라서 함수 형태로 작성해주는것이 좋다. 
               // data : {
               //     name : 'wony',
               // },
               data() {
                   return {
                       name : 'wony'
                   }
               },
               methods : {
                   changeText(){
                       this.name = 'Update Text complate!!';
                   }
               }
           })
           const app = new Vue({
               el: "#app", 
               data : {
                   name : 'first Text',
               },
               methods : {
   
               }
           })
   
       </script>
   </body>
   ```

2. Component 지역변수로 사용 

   ```vue
   <body>
       <div id="app">
           <my-button> </my-button>
       </div>
   
       <script>
           // 컴포넌트 전역 설정
           Vue.component('hello-world',{
               template : '<div> hello world!! </div>'
           })
           // 컴포넌트 지역 설정 
           const myButton = {
               template : `
               <div>
                   {{name}} <br>
                   <button @click="changeText" > change </button> 
                   <hello-world> </hello-world> 
               </div>
               `
               ,
               data() {
                   return {
                       name : 'wony'
                   }
               },
               methods : {
                   changeText(){
                       this.name = 'Update Text complate!!';
                   }
               }
           };
   
           const app = new Vue({ // app이라는 클래스 태그 안에서만 my-button 컴포넌트를 사용할 수 있게됨 
               el: "#app", 
               component : { // 컴포넌트를 지역으로 사용 
                   'my-button' : myButton,
               },
           })
       </script>
   </body>
   ```

   
