# Database의 트렌젝션

---

>

## 트랜잭션 ( Transaction )

### 정의 

-  하나의 처리를 여러 단계로 다루는 기능을 트랜잭션이라고 한다. 
   -  하나의 처리를 Commit이라는 명령어를 수행하기전 마지막으로 한번 더 확인할 수 있는 기회를 줌으로써 좀 더 안정적인 데이터베이스 작업을 가능하게 한다. 
   -  하나의 트랜잭션은 Commit되거나 Rollback된다.


### 사용 이유

- 데이터베이스 시스템 유지 
  - 즉, 일관성, 격리성, 내구성 및 원자성 (ACID) 이론을 준수하여 데이터의 안정성과 무결성을 보장하는 데 중요한 역할을 한다. 

### 동작 과정

1. 시작 (Begin)
   - 트랜잭션을 시작한다. 
   - 보통 **Service 로직이 있는 곳에서 처음 시작**된다. 
2. 작업 수행 (Execute)
   - 데이터베이스 작업(조회, 삽입, 갱신, 삭제 등)을 수행한다.
   - **CRUD**라고 생각하면 된다. 
3. **확인 (Commit)**
   - 모든 작업이 성공적으로 완료되었을 때, 트랜잭션의 변경 내용을 데이터베이스에 반영한다. 
   - 즉, **모든 Service로직에서 DB로의 요청이 성공했을 때 트랜잭션의 변경 내용을 데이터베이스에 반영하는 식**이다. 
4. **롤백 (Rollback)**
   - 트랜잭션 중에 작업 중 하나라도 실패한 경우, 트랜잭션을 이전 상태로 롤백하여 데이터베이스에 아무런 변경 사항이 없었던 것처럼 처리한다.
   - 즉, **Service 로직에서 DB로의 호출에 하나의 실패라도 있을 경우 트랜잭션의 변경 내용을 이전 내용으로 돌려 DB에 반영되지 안도록 한다.** 

### Commit 과 Rollback 연산

1. Commit 

   - 한개의 논리적 단위(트랜잭션)에 대한 **작업**이 **성공적**으로 끝났고 **데이터베이스가 다시 일관된 상태**에 있을 때, 
   - 이 트랜잭션이 **행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산**이다

2. Rollback
   - 하나의 트랜잭션 처리가 비정상적으로 **종료**되어 데이터베이스의 일관성을 깨뜨렸을 때, 
   - 이 트랜잭션의 **일부가 정상적으로 처리**되었더라도 트랜잭션의 **원자성을 구현**하기 위해 **이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산**이다.

### 특징 

1. 원자성 (Atomicity)
   - 트랜잭션의 모든 작업은 원자적인 단위로 간주되며, **모든 작업이 완료되거나 실패**해야 한다. 
   - 만약 어떤 작업이 실패하면 이전의 상태로 **롤백**되어야 한다. 
2. 일관성 (Consistency)
   - 트랜잭션이 실행되기 전과 후에 **데이터베이스는 일관된 상태를 유지**해야 한다. 
   - 즉, 트랜잭션이 데이터베이스의 **무결성 규칙을 위반**하지 않아야 한다.
3. 격리성 (Isolation)
   - 동시에 여러 트랜잭션이 실행되더라도 **서로에게 영향을 주지 않고**
   - 각 트랜잭션은 **격리된 환경**에서 실행되는 것처럼 보여야 한다. 
4. 내구성 (Durability)
   - 트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 저장되어야 한다. 
   - 시스템 장애 또는 중단 상황에서도 데이터의 손실이 발생하지 않아야 한다. 

### Spring에서의 사용법

- Service의 Method 위에 **`@Transactional` 어노테이션**을 붙여준다. 

  ```java
  @Service
  public class ProductService {
  
      @Autowired
      private ProductRepository productRepository;
  
      @Transactional // 2개의 DAO 호출을 하나의 트랜잭션으로 관리할 수 있다. ( 하나 에러나면 모두 롤백됨 )
      public void updateProductPrice(Long productId, double newPrice) {
          Product product = productRepository.findById(productId); // DAO로 DB 호츌 1
          product.setPrice(newPrice);
          
          productRepository.save(product); // DAO로 DB 호출 2 
      }
  }
  ```

### 트랜잭션이 Service 계층에서 사용되는 이유 

- 트랜잭션은 대부분 Service 계층에서 사용된다. 
  - 즉, **Controller 나 DAO에서 사용되기 보다는 Service 에서 사용**된다. (간혹 DAO 에서 사용할 수도 있다. )
  - 그 이유는 다음 항목들과 같다. 

1. 역할과 책임분리 
   - 각 계층( Controller, Service , DAO ) 은 자신의 역할에 집중하도록 하는것이 좋다. 
   - Service계층은 비즈니스 로직을 처리한다. 
   - 또한 Service는 DAO(데이터 액세스 계층) 와 Controller(사용자 요청 및 응답 계층) 사이에 존재하는 계층으로, 논리적으로 Service 계층에서 트랜잭션을 사용하는 것이 맞다. 
2. 컨트롤러 역할 간소화
   - 컨트롤러의 역할은 사용자 요청 및 응답으로, 해당 기능만 있는것이 좋다. 
   - 다른 복잡한 로직은 Service 계층에서 처리하는게 맞다. 
3. 유연한 트랜잭션 처리
   - Service계층 에서는 여러  DAO 메서드를 호출해 하나의 트랜잭션으로 묶어 처리가 가능하다. 
     - 여러개 중 하나만 실패하더라도 모두 롤백할 수 있는 장점이 존재 
   - 또한 하나의 컨트롤러에서 여러개의 Service 계층의 Method 를 호출할 때에도 각각을 트랜잭션으로 관리할 수 있다. 

### 트랜잭션의 상태

<img src="./images/트랜잭션 상태.jpg" width=500>

1. 활동(Active) : 트랜잭션이 실행중인 상태
2. 실패**(**Failed**) :** 트랜잭션 실행에 오류가 발생하여 중단된 상태
3. 철회(Aborted) : 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태
4. 부분 완료(Partially Committed) : 트랜잭션의 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태
5. 완료(Committed) : 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태



