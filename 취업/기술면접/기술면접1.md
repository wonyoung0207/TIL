 

# 기술면접1

---

> 자바에 관해서 
>

## 컴포넌트와 모듈의 차이

- 모듈 
  - 비슷하거나 연관성 있는 것들로 이루어진 메소드나 클래스의 집합으로, 재사용이 가능한 코드의 모음이다.
  - 자동차로 예를 들자면 엔진을 이루고 있는 구성품들의 집합을 엔진이라고 하고 엔진을 모듈이라고 할 수 있다. 
  - 장점
    - 코드의 재사용 및 유지보수를 쉽게 한다. 
- 컴포넌트 
  - 컴포넌트는 소프트웨어 재사용의 중요성 과 필용성을 위해 나온 기술로 , 하나의 부품 또는 기능의 최소 단위이다. 
- Client-Server 시스템에서 하나의 서버가 10개의 클라이언트에게 정보를 제공할 경우를 보자.
  - 실행 중인 소프트웨어는 서버 1개, 클라어언트 10개로 컴포넌트는 11개라 할 수 있다.
  - 반면, 만들어진 산출물은 서버, 클라이언트 이렇게 2개라 할 수 있다.
- 모듈은 실질적으로 **구현이 된 단위**
- 컴포넌트는 실제적으로 **동작하고 있는 엔티티** 



## 자바란 무엇인가

- 자바는 **객체지향프로그래밍 언어**로서 **보안성이 뛰어나며** 컴파일한 코드는 **다른 운영체제에서 사용**될 수 있도록 **클래스로 제공**된다. 
-  C++언어의 객체지향적인 장점을 살리면서 분산환경을 지원해 효율적이다.



## 자바의 구동원리

1. 자바로 작성한 코드는 [.java]라는 확장자를 가진다.
2.  자바에 존재하는 javac라는 전용컴파일러가 [.java]로 끝나는 자바코드를 컴퓨터가 이해할 수 있도록 프로그래밍 언어를 기계어로 변경한다.
3. 이떄 기계어로 된 [.class]라는 확장자를 가진 파일이 생성되는데 [.class]파일은 JVM을 통해서 실행된다. 



## JVM의 특징

- 자바 가상머신이라 불리며 자바소스로부터 만들어진 바이너리파일 즉 [.class]파일을 실행하기 위해 필요하다.
- java가 OS에 구애받지 않고 재사용가능하게 해준다.
- 그리고 자동메모리관리기법인 Garbage Collection을 수행한다.
- JRE와 JDK
  - JRE : 자바실행환경. JVM으로 자바프로그램을 동작시킬 때 필요한 파일들을 가지고 있습니다.
  - JDK : JAVA 개발을 하기위해 필요한 환경입니다. JDK에는 JRE가 포함되어 있습니다.



## 객체지향과 절차지향의 차이점

### 절차지향
  - 절차지향 프로그래밍이란 물이 위에서 흐르는 것과 같이 순차적인 처리가 중요시되며 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법입니다. 
  - 장점
    - 컴퓨터의 처리구조와 유사해 실행속도가 빠르다
  - 단점
    - 유지보수가 어렵고 실행순서가 정해져있어 코드의 순서가 바뀌면 결과값이 달라질 수 있고 디버깅이 어렵다

### 객체지향

- 객체지향은 실제세계를 모델링하여 소프트웨어를 개발하는 방법입니다.
- 마치 컴퓨터 부품을 하나씩 사다가 컴퓨터를 조립하는 것과 같은 방법입니다.
- 장점
  - 코드의 재활용성이 높고 디버깅이 쉽다.
- 단점
  - 처리속도가 절차지향보다 느리고 설계에 많은 시간이 소요된다



## 객체지향 언어의 특징

1. 캡슐화
   - 클래스 안에 **서로 연관있는 속성과 기능들을 하나의 캡슐(capsule)로 만들어 데이터를 외부로부터 보호하는 것**
     - 서로 관련 있는 데이터와 이를 처리할 수 있는 기능들을 한곳에 모아 관리하는 것
   - 데이터 은닉, 데이터 보호를 하기 위한 특징이다. 
     - **데이터 보호(data protection)** – 외부로부터 클래스에 정의된 속성과 기능들을 보호
     - **데이터 은닉(data hiding)** – 내부의 동작을 감추고 외부에는 필요한 부분만 노출
   - 방법
     1. 멤버 변수 앞에 **접근 제어자 private** 를 붙여 외부에서 사용하지 못하게 함 
     2. 해당 값을 꺼내오기 위해 **Set과 Get 메소드** 이용 
2. 추상화
   - **불필요한 세부 사항들은 제거하고 가장 본질적이고 공통적인 부분만을 추출하여 표현**하는 것 
   - 추상화를 구현할 수 있는 문법 요소로는 **추상 클래스(abstract class)**와 **인터페이스(interface)**가 있다.
3. 다형성
   - **어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질**을 의미
   - 대표적으로 **메서드 오버라이딩**과 **메서드 오버로딩(method overloading)**이 있다.
4. 상속
   -  **기존의 클래스를 재활용하여 새로운 클래스를 작성하는 자바의 문법 요소**를 의미



## 오버라이딩과 오버로딩 

1. 오버라이딩
   - 상속을 이용해 기존 구현되어있던 메소드의 틀만 가져와 재정의 하는 것을 뜻한다. 
   - 하나의 메소드 이름을 통해 여러가지의 기능을 만들어 낼 수 있다. 
     - **객체지향의 특징인 추상화와 연관**이 있다. 
2. 오버로딩
   - 하나의 클래스 안에서 인스턴스 개수나 형식이 다른 동일한 이름의 메소드를 여러개 정의하는 것을 뜻한다.
   - **매개변수의 갯수, 타입, 순서**를 변경해 구현할 수 있다. 
     - 반환타입은 오버로딩에 속하지 않는다. 
     - 메소드의 이름은 동일해야 한다. 



## 기본형 변수와 참조형 변수

1. 기본형 변수
   1. char
   2. byte
   3. short
   4. int
   5. long
   6. float
   7. double
   8. boolean
2. 참조형 변수 
   - 기본형 변수를 제외한 변수로, 값은 heap영역에 저장하고 해당 주소를 stack 영역에 저장하는 변수이다. 
   -  stack 영역의 참조형 변수는 heap 영역에 저장되어있는 실질적인 데이터의 주소를 가진다. 



## 스택 오버플로우 발생 원인 

- stack포인터가 stack의 경계를 넘어 설 때 일어난다. 
- 프로그램이 시작되면 각각의 프로그램마다 이용 가능한 공간만큼의 제한된 Stack 영역이 할당된다.
  - 이때 이 공간의 크기 이상을 사용하려고 하면 오버플로가 발생하게 된다. 
- 넘칠경우 프로그램끼리 충돌할 수 있기 때문에 신경써서 코딩해야 한다. 
  - 대부분 무한루프에서 많이 발생한다. 



## 메모리 누수 

- 프로그램이 필요하지 않은 메모리를 계속 점유하고 있는 현상이다. 
- 자바의 가비지 컬렉션(Garbage Collection)이 메모리를 관리하지만 이때 정리되지 못하는 메모리들이 쌓이는것이 "메모리 누수 "이다. 
- GC가 빈번히 발생하면 프로그램의 응답속도가 늦어지다 결국 Out of memory 오류로 프로그램이 종료된다. 
- 막기 위한 방법
  - 참조값을 갖는 변수가 최소한의 유효범위안에 있도록 한다. 
  - Local 변수로 만들경우 자동으로 가바지컬렉션의 대상이 된다. 



## Static 

- Static은 하나의 별도 공간으로 메모리가 잡히며 프로그램 시작 시 선언되어 프로그램 종료 시 까지 유지된다. 
- 정적인 변수로 만들어 여러 곳에서 값을 공유하고 싶은 상황에서 사용되어 메모리의 이점을 얻을 수 있다. 



## 싱글톤 패턴

- **객체의 인스턴스가 오직 1개만 생성**되는 패턴을 의미

- 만드는 방법

  1. 객체의 생성자를 private 로 지정
  2. 객체 안에서만 인스턴스화 할 수 있도록 메소드와 필드를 구성한다. 

- 예시

  ```java
  public class Singleton {
      private static Singleton instance = new Singleton();//객체 선언 및 생성 
  
      private Singleton() { // 객체 생성 
          // 생성자는 외부에서 호출못하게 private 으로 지정해야 한다.
      }
  
      public static Singleton getInstance() {
          return instance;  
      }
  }
  ```

- 장점

  1. 메모리 절약
     -  초기 한번만 메모리 할당되고 추후에는 바로 접근할 수 있다.
     - 속도에서 이점을 낼 수 있다. 
  2. 데이터 공유가 쉬워짐 
     - 전역으로 사용할 수 있는 Static 이기 때문에 다른 클래스에서 쉽게 해당 객체의 인스턴스들을 사용할 수 있다. 
  3. 인스턴스가 한개만 존재하는 것을 보증할 수 있다. 
     - 해당 인스턴스가 한개인것을 보장할 수 있다. 

- 단점

  1. 코드가 복잡
     - 싱글톤을 구현하기 위해선 많은 코드가 동반된다. 
  2. 테스트가 어렵다. 
     - 자원을 항상 공유하고 있어 테스트 하려면 매번 인스턴스 상태를 초기화 시켜줘야한다. 
  3. 결합도가 높아져 '개방-폐쇄' 원칙 위반(=객체지향 설계 원칙에 어긋남)
     - 객체지향의 장점인 추상화와 캡슐화의 원칙이 위반될 수 있다. 

- 따라서 싱글톤 패턴은 스프링 컨테이너 같은 프레임워크의 도움을 받으며 사용한다면 문제점을 보완해 좋은 기능으로 사용할 수 있다. 



## 익명클래스

- 익명클래스

  - 클래스의 이름이 없는 것을 말한다. 

-  사용이유

  - 한번만 사용되고 나중에 다시 재사용 될 일이 없는 클래스에 사용된다. 

- 장점

  - 유지보수에 유리하다. 

- 사용 방법

  ```java
  Insect spider1 = new Insect(){
  
      String name = "무당거미";
      //거미줄을 치다.
      void cobweb(){
          System.out.println("사각형으로 거미줄을 친다.");
      }
  
      @Override
      void attack() {
          System.out.println(name + " 독을 발사한다.");
      }
  };
  ```



## Thread 

- 하나의 프로세스 내부에서 독립적으로 실행되는 하나의 작업단위
  - 운영체제에 의해 관리되는 하나의 작업(task)를 의미한다. 
  - 프로세스
  - 프로그램이 CPU에 올라가 실행되고있는 상태 
- 예시
  - JVM에 의해 하나의 프로세스가 생성된다. 
    - 프로세스안에는 일반적으로 하나의 main() 이 있다. 
    - 이때 main() 안에서 동작하는 모든것이 하나의 스레드이다.
  -   다른 스레드를 만들기 위해서는 Thread 클래스를 상속하거나 Runnable 인터페이스를 구현하면 된다. 



## Multi Thread (멀티 스레드)

- **하나의 프로세스** 내에서 **둘 이상의 스레드가 동시에 작업을 수행**하는 것을 의미 
- 특징 
  - 각각의 스레드가 자신이 속한 프로세스의 메모리를 공유한다. 
- 장점
  - 시스템 자원의 낭비가 적다 .
    - 자신이 속한 프로세스의 메모리를 공유하기 때문에 
  - 응답성이 좋다. 
    - 하나의 스레드가 작업을 할 때 다른 스레드가 별도의 작업을 할 수 있다. 
- 단점
  - 복잡성
    - 구현하기위해선 별도의 Thread 클래스를 상속받아 구현해야 한다. 
  - 동기화 문제 
    - 같은 자원을 스레드가 요청할 경우를 대비해 동기화 처리를 해줘야한다. 
    -  하나의 자원을 누가 사용하고 있다면 다음 스레드는 해당 자원을 사용할 수 없도록  동기화 처리해줘야한다. 
    - 동기화란, 데이터의 **요청과 결과가 동시에 일어나는 것** 이다. 



## 문맥교환

- 현재 CPU를 사용중인 프로세스의 CPU 제어권이 다른 프로세스로 이양되는 과정
  - 컴퓨터에서 동시에 처리할 수 있는 **최대 작업의 수**는 **CPU의 코어수**와 같다. 
  - 만약 **CPU의 코어 수 보다 더 많은 스레드가 실행**되면 각 코어가 정해진 시간동안(타이머가 있음) **여러 작업을 번갈아가며** 일을수행하게 된다. 
  - 여러 프로세스가 일을 처리하기 위해 CPU 할당을 경쟁하게 되고 이때 각 **스레드가 서로 교환**이 되는데, 이 과정이 **"문맥교환"** 이다.  
- 사용이유
  - 멀티 스레딩의 효율성 
    - 문맥교환에 걸리는 시간이 커질수록 멀티 스레딩의 효율이 저하된다. 



## 제네릭

- 다양한 타입의 객체들을 다루는 메소드나 컬렉션 클래스에 **컴파일 시 타입체크**를 해주는 기능 
- 즉, 클래스 내부에서 사용할 데이터타입을 **인스턴스 생성시 확정**하는 것이다. 



## 람다식 

- 익명함수의 한 종류로, 괄호와 화살표를 이용해 함수를 선언하는 방법이다. 

- 특징 

  1. 지역변수의 상수처리 
     - final을 붙이지 않아도 람다식 내 지역변수는 상수로 간주된다. 
  2. 변수명 중복불가 
     - 람다식으로 선언된 변수명은 다른 변수명과 중복될 수 없다. 

- 장점

  1. 메소드의 이름이 필요 없다. 
  2. 불필요한 코드 제거로 인한 생산성 증가   
  3. 가독성 증가 

- 단점

  1. 재사용 불가 
  2. 디버깅 어려움
  3. 비슷한 함수 중복으로 인한 코드 증가 

- 사용방법 

  1. 람다는 "**매개변수 : ()**" 와 "**화살표 : ->**"를 이용해 (->) 함수몸체로 이용하여 사용 할 수 있다.
  2. 함수몸체가 단일 실행문이면 괄호{}를 생략 할 수 있다.
  3. 함수몸체가 return문으로만 구성되어 있는 경우 괄호{}를 생략 할 수 없다.

- 예시

  ```java
  // 람다 방식
  (매개변수, ... ) -> { 실행문 ... }
  
  // 예시
  () -> "Hello World!";
  
  new Thread(()->{
        System.out.println("Welcome Heejin blog");
  }).start();
  
  (int x, int y) -> x+y
  (x, y) -> x+y
  (x, y) -> { return x+y; }
  ```

  

##  Stack 과 Heap

1. Stack
   - heap 영역에 생성된 Object 타입의 데이터 주소가 할당된다. 
   - 원시 타입의 데이터가 값과 함께 할당된다. 
   - 각 Thread는 자신만의 stack을 가진다. 
   - 정적 메모리를 사용 
2. Heap
   - 주로 긴 생명 주기를 가지는 데이터들이 저장딘다. 
   - 애플리케이션의 모든 메모리 중 stack 에 있는 데이터를 제외한 부분
   - 모든 Object 타입이 저장되는 곳 
   - 스레드 갯수에 상관없이 단 하나의 heap 영역만 존재 
   - heap 영역에 있는 오브젝트들을 가리키는 래퍼런스 변수가 stack 에 올라감 
   - 동적 메모리를 사용 

<img src="./images/stack과heap.png">

