# JavaScript의 실행 컨텍스트

---

>

### 실행 컨텍스트 

### 정의 

- 자바스크립트 코드가 실행되는 환경
  - 실행할 코드에 제공할 환경 정보들을 모아놓은 객체로, 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념
  - 함수 하나의 공간 또한 실행 컨텍스트이다. 
- FILO (First In, Last Out) 의 구조이기에 **순서를 보장**한다. 

### 동작 방법

<img src="./images/컨텍스트 실행 예시.png" width=600>

- 자바스크립트 파일이 열리는 순간 전역 컨텍스트가 활성화된다. 
- 또한 하나의 함수가 실행되면 함수 실행에 해당하는 **`실행 컨텍스트`**가 생성되고, 자바스크립트 엔진에 있는 콜 스택에 차곡차곡 쌓인다.
  - 즉, 함수 호출을 발견할 때마다, 함수의 실행 컨텍스트를 스택에 `push` 한다.
  - 중요한 점은 함수 실행 컨텍스트는 함수의 선언시 만들어지는게 아니라, 함수의 **실행**시에 만들어진다는 점이다. 
- 함수의 선언시에는 해당 함수가 어디까지인지 파악 후 스택에 저장한다. 
  - 그 후에 환경을 새로 만드는데, 이것이 실행 컨텍스트 이다.  

### 컨텍스트 종류

1. 전역 컨텍스트 
   - 전역 영역에 존재하는 컨텍스트로, **모든 스크립트 코드는 전역 실행 컨텍스트 안에서 실행**된다. 
     - 따라서 프로그램에 단 한개만 존재한다. 
   - 브라우저의 경우에는 window 객체, node.js 의 경우에는 global 객체가 곧 전역객체이다. 
2. 함수 실행 컨텍스트
   - 함수 내에 존재하는 컨텍스트 
   - 함수가 실행될 떄 생성되며, 함수별로 고유의 실행 컨텍스트를 가진다. 
3. eval() 실행 컨텍스트 
   - 이제 쓰지 않는 eval() 함수에 의해 생성되는 실행 컨텍스트이다.

### 구조 및 구성 요소

<img src="./images/컨텍스트 구조 예시.png" width=600>

- `LexicalEnvironment` 컴포넌트와 `variableEnvironment` 컴포넌트, thisBinding 으로 구성되며, 활성화되는 시점에서 3가지 정보를 수집한다. 
  1. **VariableEnvironment**: 
     - 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보
     - **선언 시점의 LexicalEnvironment의 스냅샷**으로, 변경 사항은 반영되지 않는다.
  2. **LexicalEnvironment** 
     - 처음에는 VariableEnvironment와 같지만 변경 사항이 **실시간으로 반영**된다.
  3. **ThisBinding** 
     - **this 식별자**가 바라봐야 할 대상 객체를 의미한다.
  4. 실행 컨텍스트를 생성할 때 VariableEnvironment에 정보를 **먼저 담은** 다음, 이를 **그대로 복사**해서 **LexicalEnvironment를 만들**고, 이후에는 LexicalEnvironment를 주로 활용
- 이 두 환경의 내부는 다시 `EnvironmentRecord` 와 `OuterEnvironmentReference` 로 구성
  1. **EnvironmentRecord** 
     - 함수 안의 코드가 실행되기 전에 **현재 컨텍스트와 관련된 코드의 식별자 정보**(매개변수의 이름, 함수 선언, 변수명 등)가 저장
  2. **OuterEnvironmentReference** 
     - **상위 스코프**를 뜻함. 
     - 즉, **현재 environment record보다 바깥에 있는 environment record를 참고**한다는 뜻이며 **해당 실행 컨텍스트를 생성한 함수의 바깥 환경**을 가리킨다.
- 구성요소
  - 실행 컨텍스트는 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘으로 이루어 진다. 
  - 즉, 실행컨텍스트 별로 식별자가 등록되며 관리된다. 

### 발생문제 : 함수 안에 또 다른 함수가 존재한다고 했을 때 this의 값이 달라짐 

- 함수마다 실행 컨텍스트가 생겨나고, 해당 실행 컨텍스트마다 this 의 의미를 가지게 된다. 

  - 즉, 함수 안에 또다른 함수를 사용한다면 this의 의미가 바뀐다는 것이다. 

  ```js
  const str = '안녕';
  console.log(str); // '안녕' 출력됨 
  
  function outer() { // outer() 컨텍스트 생성 
    function inner() { // inner() 컨텍스트 생성 
      const greeting = '하이';
      console.log(greeting);
      console.log(this.str); // undefined 출력됨 
    }
  }
  ```

  