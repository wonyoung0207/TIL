# 클로저 개념정리

---

>

## 클로저란? 

1. 클로저는 “함수가 선언될 때 ‘이 스코프(scope)에 있는 변수들’을 함께 기억해서, 그 함수가 실행이 끝난 뒤에도 계속 꺼내 쓸 수 있게 해주는 가방”
2. **클로저 = 함수가 자기만의 가방을 들고 다니는 것**
   1. 가방 속엔 그 함수가 선언될 때의 변수들이 담겨 있다.
3. 왜 필요하냐면?
   1. 함수 실행이 끝나도 그 변수들을 계속 사용할 수 있어서, 상태를 유지하거나 숨길 수 있다.
4. 주의할 점
   - **가방(클로저)이 무거워지면(변수가 많으면) 메모리 사용량이 커진다.**

## 정리

1. , “함수와 그 함수가 선언된 당시의 변수들을 묶어두는 작은 가방”이라고 기억

## 예제

- `makeGreeter('김철수')`를 호출하면
  1. `greeting` 변수(`안녕하세요, 김철수님!`)를 가방에 넣고,
  2. 내부 함수 `sayHello`를 꺼내 와서 돌려줍니다.
- 이때, `sayHello` 함수가 “자신이 태어날 때(선언될 때) 있던 변수(greeting)를 계속 기억”하고 있기 때문에,
  - `greeterKim()`을 호출하면 `greeting`이 `"안녕하세요, 김철수님!"`인 상태로 동작하고
  - `greeterLee()`를 호출하면 `greeting`이 `"안녕하세요, 이영희님!"`인 상태로 동작합니다.
- 이처럼 **“함수(여기서는 `sayHello`)가 만들어진 당시의 환경(여기서는 `greeting` 변수의 값)을 계속 챙겨서 갖고 있는 것**이 바로 클로저이다. 

```JS
function makeGreeter(name) {       // makeGreeter라는 함수를 정의
  const greeting = `안녕하세요, ${name}님!`;  // 가방에 담을 물건(변수)

  function sayHello() {           // 내부 함수(이게 클로저 역할)
    console.log(greeting);        // 가방(greeting) 속 내용을 사용
  }

  return sayHello;                // 함수를 바깥으로 꺼내줌
}

const greeterKim = makeGreeter('김철수');  // 집어넣으면서 김철수 이름도 기억
const greeterLee = makeGreeter('이영희');  // 이쪽 가방에는 이영희 이름 기억

greeterKim(); // 콘솔에 "안녕하세요, 김철수님!" 출력
greeterLee(); // 콘솔에 "안녕하세요, 이영희님!" 출력

```

