# WebGLCubeRenderTarget & CubeCamera로 동적 환경광 구현

---

>

## 1. 핵심 개념

- **WebGLCubeRenderTarget**
   → 큐브맵 텍스처를 GPU에 저장할 “그릇”
- **CubeCamera**
   → 씬을 6방향(px, nx, py, ny, pz, nz)으로 렌더링해 CubeRenderTarget에 채워 넣음
- 결과: `cubeRenderTarget.texture` → **환경맵**처럼 활용 가능
- 단, 
  - `CubeRenderTarget + CubeCamera` = **반사/환경광 대체**까지만 가능

##### 전체적인 광량을 표현하지 못함 => **layers 설정으로 해결** 

## 2. 기본 구조

```js
// 큐브맵 저장 공간
const cubeRT = new THREE.WebGLCubeRenderTarget(256)

// 씬을 찍을 큐브 카메라
const cubeCam = new THREE.CubeCamera(0.1, 1000, cubeRT)
scene.add(cubeCam)

// 씬의 환경광 대체
scene.environment = cubeRT.texture
```

## 3. 동적 업데이트

```js
function animate() {
  requestAnimationFrame(animate)

  // 현재 씬을 큐브맵으로 렌더링
  cubeCam.update(renderer, scene)

  renderer.render(scene, camera)
}
```

- **정적 환경광**: 초기 1회만 `update`
- **동적 환경광/반사**: 매 프레임 `update`

## 4. 반사체 구현 예시

```js
// 반사 머티리얼
const material = new THREE.MeshStandardMaterial({
  metalness: 1,
  roughness: 0,
})

// 반사 구체
const sphere = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 32), material)
scene.add(sphere)

cubeCam.update(renderer, scene)
```

## 5. 장단점

- HDRI 없이 환경광/반사 구현 가능
- 씬의 실제 오브젝트가 반사되어 자연스러움
- 성능 비용 큼 (프레임마다 6번 렌더링)
- 오브젝트가 많으면 FPS 저하 → 선택적으로 적용 필요

## 정리

- `WebGLCubeRenderTarget`: 큐브맵 저장소
- `CubeCamera`: 씬을 6방향으로 찍어서 큐브맵 생성
- 활용
  - `scene.environment` → 환경광 대체
  - `material.envMap` → 동적 반사체