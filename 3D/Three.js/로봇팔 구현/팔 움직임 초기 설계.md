# 팔 움직임 초기 설계 

---

>

## 목적

- Blender 의 IK Bone 은 export 시 가져올 수 없음. Threejs 에서 IK Bone 같은 기능을 구현하고자함 
- 로봇팔 직접 **IK 동작 구현 매커니즘** (base 부터 child 에다가 chain 처럼 arm ~ gripper 까지 연결 )
  - 하나의 chain 으로 부모 , 자식으로 되어있어야 중간 움직이면 그 자식들이 따라오게 구현함 

## 방법

- 자식
  - Gripper 부분으로, model 끝부분에 달려있는 부분
- 부모 
  - base 부분으로 , 땅에 박혀있는 부분 

```js
function findRobotParts() {
    core.scene?.add(robotModelTest)

    // 씬 그래프 구조를 변경하기 전, 현재의 월드 행렬을 강제로 업데이트합니다.
    // attach() 시 올바른 월드 트랜스폼을 계산하기 위해 필요합니다.
    robotModel.updateMatrixWorld(true)

    const partsToAttach: THREE.Object3D[] = []

    robotModel.traverse((child) => {
      const childName = child.name.toLowerCase()
      
      // Base 부품들
      if (childName.includes('base_rotation')) {
        robotParts.base_rotation = child
      } else if (childName === 'base') {
        robotParts.base = child
      }
      
      // Arm 부품들 (arm1 ~ arm4)
      if (childName === 'arm1') {
        robotParts.arm1 = child
      } else if (childName === 'arm2') {
        robotParts.arm2 = child
      } else if (childName === 'arm3') {
        robotParts.arm3 = child
      } else if (childName === 'arm4') {
        robotParts.arm4 = child
      }

      // Joint 부품들
      if (childName.includes('arm1_joint')) {
        robotParts.arm1_joint = child
      } else if (childName.includes('arm2_joint')) {
        robotParts.arm2_joint = child
      } else if (childName.includes('arm3_joint')) {
        robotParts.arm3_joint = child
      } else if (childName.includes('arm4_joint')) {
        robotParts.arm4_joint = child
      }
      
      // Grip 부품들
      if (childName === 'grip_arm_base') {
        robotParts.grip_arm_base = child
      } else if (childName === 'grip_arm_left') {
        robotParts.grip_arm_left = child
      } else if (childName === 'grip_arm_right') {
        robotParts.grip_arm_right = child
      } else if (childName === 'grip_arm_left_joint') {
        robotParts.grip_arm_left_joint = child
      } else if (childName === 'grip_arm_right_joint') {
        robotParts.grip_arm_right_joint = child
      }


    })

    let robotObject : THREE.Object3D = new THREE.Object3D()


    // 1. base
    const robotBase = robotParts.base!
    robotBase.attach(robotParts.base_rotation!)


    // // 2. arm
    const armNames = ['arm1', 'arm2', 'arm3', 'arm4']
    const prevArray : {arm : THREE.Object3D, joint : THREE.Object3D}[] = []
    let previousArm : THREE.Object3D | null = null

    armNames.forEach((armName) => {
      const arm = robotParts[armName as keyof typeof robotParts]
      const joint = robotParts[`${armName}_joint` as keyof typeof robotParts]
      if (!arm || !joint) return

      joint.attach(arm)
      
      // 첫 arm이면 루트에 붙여야 함 (예: base or robotRoot)
      if (!previousArm) {
        robotParts.base_rotation!.attach(joint) // or armBase.attach(joint)
      }


      if (previousArm) {
        previousArm.attach(joint)
      }

      // 배열에 기록
      prevArray.push({ arm, joint })

      // 다음 루프를 위해 현재 arm을 previousArm으로 저장
      previousArm = arm
    })  



    // 3. grip
    const gripNames = ['grip_arm_left', 'grip_arm_right']
    const gripBase = robotParts.grip_arm_base!

    gripNames.forEach((gripName) => {
      const grip = robotParts[gripName as keyof typeof robotParts]
      const joint = robotParts[`${gripName}_joint` as keyof typeof robotParts]
      if (!grip || !joint) return

      joint.attach(grip)

      gripBase.attach(joint)
    })  

    previousArm!.attach(gripBase)
    robotObject = robotBase
    
    robotModelTest.attach(robotObject)

    // 로봇 움직임 테스트 
    robotParts.base_rotation!.rotation.y = Math.PI / 2
    robotParts.arm1_joint!.rotation.x = Math.PI / 4 
    // robotParts.arm2_joint!.rotation.x = Math.PI 

  }
```

