# 블로킹과 논블로킹 개념정리 

---

>블로킹과 논블로킹 개념정리 

## 블로킹 (Blocking I/O)

- **쓰레드 기반 동기방식(Blocking I/O)**
- 하나의 쓰레드가 request를 받으면 모든 처리가 완료될때까지 기다리다가 처리결과가 완료되면 다시 응답을 보냄
- 기존 업무 처리가 완료되기 전에 또다른 request가 있으면 새로운 쓰레드가 업무를 처리함.
- 동시 request가 많은 경우 **많은 쓰레드가 필요**하게 되어 서버 과부하

```C
#include <stdio.h>

int sum(int a, int b)
{
    return a + b;
}

int main()
{
   int result;
   result = sum(1, 2);           // 1
   printf("sum: %d\n", result);  // 2

   return 0;                     // 3
}
```

- sum() 연산이 끝날때까지 기다렸다가 다음줄인 printf() 를 실행해야한다. 

---

## 논블로킹 ( Non-Blocking I/O)

- **단일쓰레드 이벤트 루프 기반 비동기방식( Non-Blocking I/O)**
- **하나의 쓰레드**가 request를 받으면 바로 다음 처리에 요청을 보내놓고 다른 작업을 처리하다가 먼저 요청한 작업이 끝나면 **이벤트를 받아서 응답**을 보낸다.
- 동시 request가 오더라도 처리가 완료될때까지 기다리지 않아도 되기 때문에 서버 부하가 적다.

- 따라서 논블로킹의 장점인 **하나의 쓰레드로 진행**되어 서버 과부하를 줄일 수 있고 **비동기방식으로 진행**되 다음 작업을 빠르게 시작하고 작업이 끝나면 이벤트를 통해 작업이 끝났다는 것을 알고 응답을 보낸다. 

  ```java
  const fs = require('fs')
  
  fs.readFile('./hello.txt' /* 1 */, function (err, data) {
    console.log(data) // 3
  })
  
  console.log('Hello JavaScript') // 2
  ```

  - fs.readFile() 함수의 리턴을 기다리지 않고 다음줄인 console.log() 를 실행한다. 